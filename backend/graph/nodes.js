/**
 * N√≥s da M√°quina de Estados do Chatbot Pok√©mon
 * Cada n√≥ representa um estado e cont√©m a l√≥gica de processamento
 */

const PokeAPIService = require('../services/pokeapi');

// Inicializar servi√ßo
const pokeService = new PokeAPIService();

// ============================================
// ESTADO COMPARTILHADO (State Schema)
// ============================================
const initialState = {
  messages: [],           // Hist√≥rico de mensagens
  userInput: '',          // √öltima entrada do usu√°rio
  currentNode: 'start',   // N√≥ atual
  context: {              // Contexto da conversa
    pokemonData: null,
    comparisonData: [],
    waitingFor: null,     // O que estamos esperando do usu√°rio
    evolutionChain: null,
    lastError: null
  },
  sessionId: null,
  metadata: {
    startTime: Date.now(),
    interactionCount: 0
  }
};

// ============================================
// UTILIT√ÅRIOS
// ============================================
const utils = {
  /**
   * Adiciona mensagem ao hist√≥rico
   */
  addMessage(state, role, content, data = null) {
    return {
      ...state,
      messages: [
        ...state.messages,
        {
          role,
          content,
          data,
          timestamp: Date.now()
        }
      ]
    };
  },

  /**
   * Atualiza contexto
   */
  updateContext(state, updates) {
    return {
      ...state,
      context: {
        ...state.context,
        ...updates
      }
    };
  },

  /**
   * Incrementa contador de intera√ß√µes
   */
  incrementInteraction(state) {
    return {
      ...state,
      metadata: {
        ...state.metadata,
        interactionCount: state.metadata.interactionCount + 1
      }
    };
  },

  /**
   * Formata stats para exibi√ß√£o
   */
  formatStats(stats) {
    return `
üìä **Estat√≠sticas:**
‚ù§Ô∏è  HP: ${stats.hp}
‚öîÔ∏è  Ataque: ${stats.attack}
üõ°Ô∏è  Defesa: ${stats.defense}
‚ú® Atq. Especial: ${stats.specialAttack}
üåü Def. Especial: ${stats.specialDefense}
‚ö° Velocidade: ${stats.speed}
üí™ **Total: ${stats.total}**`;
  },

  /**
   * Valida se entrada √© um n√∫mero v√°lido de Pok√©mon
   */
  isValidPokemonId(input) {
    const num = parseInt(input);
    return !isNaN(num) && num > 0 && num <= 1010; // Total de Pok√©mon at√© Gen 9
  }
};

// ============================================
// N√ì 1: START (Boas-vindas)
// ============================================
const startNode = async (state) => {
  console.log('[NODE] startNode - Iniciando conversa');

  const welcomeMessage = `
üéÆ **Bem-vindo ao Pok√©Dex Assistant!**

Ol√°, Treinador! Eu sou seu assistente pessoal do mundo Pok√©mon. 

Posso te ajudar a:
1Ô∏è‚É£ Buscar informa√ß√µes de qualquer Pok√©mon
2Ô∏è‚É£ Comparar dois Pok√©mon lado a lado
3Ô∏è‚É£ Ver cadeias de evolu√ß√£o
4Ô∏è‚É£ Buscar Pok√©mon por tipo

Digite o **n√∫mero da op√ß√£o** ou me diga o que voc√™ quer fazer!`;

  let newState = utils.addMessage(state, 'assistant', welcomeMessage);
  newState = utils.updateContext(newState, { 
    waitingFor: 'menu_choice',
    lastError: null 
  });
  newState = utils.incrementInteraction(newState);
  newState.currentNode = 'menu';

  return newState;
};

// ============================================
// N√ì 2: MENU (Roteamento)
// ============================================
const menuNode = async (state) => {
  console.log('[NODE] menuNode - Processando escolha do menu');

  const input = state.userInput.toLowerCase().trim();
  
  // Se n√£o h√° input (acabou de entrar do start ou de outro n√≥), apenas mant√©m o estado
  if (!input) {
    console.log('[NODE] menuNode - Sem input, aguardando escolha do usu√°rio');
    return {
      ...state,
      currentNode: 'menu'
    };
  }

  // Detectar inten√ß√£o do usu√°rio
  let nextNode = 'menu';
  let responseMessage = '';

  // Op√ß√£o 1: Buscar Pok√©mon
  if (input.includes('1') || input.includes('buscar') || input.includes('procurar') || input.includes('informa√ß√£o')) {
    nextNode = 'search';
    responseMessage = 'üîç **Buscar Pok√©mon**\n\nDigite o nome ou n√∫mero do Pok√©mon que voc√™ quer conhecer!\nExemplo: "Pikachu" ou "25"';
  }
  // Op√ß√£o 2: Comparar
  else if (input.includes('2') || input.includes('comparar') || input.includes('compara√ß√£o')) {
    nextNode = 'compare';
    responseMessage = '‚öñÔ∏è **Comparar Pok√©mon**\n\nDigite o nome ou n√∫mero de dois Pok√©mon separados por v√≠rgula.\nExemplo: "Charizard, Blastoise" ou "6, 9"';
  }
  // Op√ß√£o 3: Evolu√ß√£o
  else if (input.includes('3') || input.includes('evolu√ß√£o') || input.includes('evoluir')) {
    nextNode = 'evolution';
    responseMessage = 'üîÑ **Cadeia de Evolu√ß√£o**\n\nDigite o nome ou n√∫mero do Pok√©mon para ver sua linha evolutiva completa!';
  }
  // Op√ß√£o 4: Por tipo
  else if (input.includes('4') || input.includes('tipo') || input.includes('type')) {
    nextNode = 'type_search';
    responseMessage = 'üè∑Ô∏è **Buscar por Tipo**\n\nDigite o tipo de Pok√©mon que procura:\n(fire, water, grass, electric, psychic, dragon, etc.)';
  }
  // Op√ß√£o de sair
  else if (input.includes('sair') || input.includes('tchau') || input.includes('bye')) {
    nextNode = 'end';
    responseMessage = 'üëã At√© logo, Treinador! Foi √≥timo te ajudar na sua jornada Pok√©mon!';
  }
  // Entrada inv√°lida
  else {
    responseMessage = `
‚ùå Desculpe, n√£o entendi sua escolha.

Por favor, escolha uma das op√ß√µes:
1Ô∏è‚É£ Buscar Pok√©mon
2Ô∏è‚É£ Comparar Pok√©mon
3Ô∏è‚É£ Ver Evolu√ß√£o
4Ô∏è‚É£ Buscar por Tipo

Ou digite "sair" para encerrar.`;
  }

  let newState = utils.addMessage(state, 'user', state.userInput);
  newState = utils.addMessage(newState, 'assistant', responseMessage);
  newState = utils.updateContext(newState, { 
    waitingFor: nextNode === 'menu' ? 'menu_choice' : 'pokemon_input' 
  });
  newState = utils.incrementInteraction(newState);
  
  // Limpa o input ap√≥s processar a escolha do menu
  newState.userInput = '';
  newState.currentNode = nextNode;

  return newState;
};

// ============================================
// N√ì 3: SEARCH (Buscar Pok√©mon)
// ============================================
const searchNode = async (state) => {
  console.log('[NODE] searchNode - Buscando Pok√©mon');

  const input = state.userInput.trim().toLowerCase();
  let newState = utils.addMessage(state, 'user', input);

  // Verificar comandos especiais antes de buscar Pok√©mon
  if (input.includes('menu')) {
    const response = 'üìã Voltando ao menu principal...';
    newState = utils.addMessage(newState, 'assistant', response);
    newState = utils.incrementInteraction(newState);
    newState.userInput = '';
    newState.currentNode = 'menu';
    return newState;
  }
  
  if (input.includes('evol')) {
    const response = 'üîÑ Indo para visualiza√ß√£o de evolu√ß√£o...';
    newState = utils.addMessage(newState, 'assistant', response);
    newState = utils.incrementInteraction(newState);
    newState.userInput = '';
    newState.currentNode = 'evolution';
    return newState;
  }

  try {
    // Buscar Pok√©mon
    const pokemon = await pokeService.getPokemon(input);
    
    // Buscar informa√ß√µes da esp√©cie
    const species = await pokeService.getSpecies(pokemon.speciesId);

    const response = `
‚ú® **${pokemon.nameCapitalized}** #${pokemon.id}

üìù ${species.description}

üè∑Ô∏è **Tipo(s):** ${pokemon.types.map(t => t.toUpperCase()).join(', ')}
üìè **Altura:** ${pokemon.height}m
‚öñÔ∏è **Peso:** ${pokemon.weight}kg

${utils.formatStats(pokemon.stats)}

üí´ **Habilidades:**
${pokemon.abilities.map(a => `‚Ä¢ ${a.name}${a.isHidden ? ' (oculta)' : ''}`).join('\n')}

${species.isLegendary ? 'üëë **Pok√©mon Lend√°rio!**' : ''}
${species.isMythical ? '‚ú® **Pok√©mon M√≠tico!**' : ''}

---
O que voc√™ quer fazer agora?
‚Ä¢ Digite outro Pok√©mon para buscar
‚Ä¢ Digite "evoluir" para ver a cadeia evolutiva
‚Ä¢ Digite "menu" para voltar ao menu principal`;

    newState = utils.addMessage(newState, 'assistant', response, pokemon);
    newState = utils.updateContext(newState, {
      pokemonData: pokemon,
      waitingFor: 'next_action',
      lastError: null
    });
    newState = utils.incrementInteraction(newState);
    
    // Marca que o input foi processado e aguarda pr√≥xima a√ß√£o
    newState.userInput = '';
    newState.currentNode = 'search';

  } catch (error) {
    console.error('[ERROR] searchNode:', error.message);

    let errorMessage = '';
    
    if (error.message === 'POKEMON_NOT_FOUND') {
      // Tentar sugest√µes
      try {
        const suggestions = await pokeService.searchPokemon(input, 5);
        if (suggestions.length > 0) {
          errorMessage = `
‚ùå Pok√©mon "${input}" n√£o encontrado.

ü§î Voc√™ quis dizer:
${suggestions.map(s => `‚Ä¢ ${s}`).join('\n')}

Tente novamente ou digite "menu" para voltar.`;
        } else {
          errorMessage = `‚ùå Pok√©mon "${input}" n√£o encontrado.\n\nTente outro nome ou n√∫mero, ou digite "menu" para voltar.`;
        }
      } catch (e) {
        errorMessage = `‚ùå Pok√©mon "${input}" n√£o encontrado.\n\nTente outro nome ou n√∫mero, ou digite "menu" para voltar.`;
      }
    } else {
      errorMessage = `‚ùå Erro ao buscar Pok√©mon: ${error.message}\n\nTente novamente ou digite "menu" para voltar.`;
    }

    newState = utils.addMessage(newState, 'assistant', errorMessage);
    newState = utils.updateContext(newState, {
      lastError: error.message,
      waitingFor: 'pokemon_input'
    });
    
    // Marca que o input foi processado (mesmo com erro)
    newState.userInput = '';
    newState.currentNode = 'search';
  }

  return newState;
};

// ============================================
// N√ì 4: COMPARE (Comparar Pok√©mon)
// ============================================
const compareNode = async (state) => {
  console.log('[NODE] compareNode - Comparando Pok√©mon');

  const input = state.userInput.trim();
  let newState = utils.addMessage(state, 'user', input);

  try {
    // Parse entrada (espera "pokemon1, pokemon2")
    const parts = input.split(',').map(p => p.trim()).filter(p => p);

    if (parts.length !== 2) {
      throw new Error('Por favor, forne√ßa dois Pok√©mon separados por v√≠rgula.\nExemplo: "Pikachu, Raichu"');
    }

    // Buscar ambos os Pok√©mon
    const [pokemon1, pokemon2] = await pokeService.getMultiplePokemon(parts);

    const response = `
‚öñÔ∏è **Compara√ß√£o: ${pokemon1.nameCapitalized} vs ${pokemon2.nameCapitalized}**

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë **Estat√≠stica**    ‚ïë **${pokemon1.nameCapitalized}** ‚ïë **${pokemon2.nameCapitalized}** ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë HP             ‚ïë ${String(pokemon1.stats.hp).padEnd(8)} ‚ïë ${String(pokemon2.stats.hp).padEnd(8)} ‚ïë
‚ïë Ataque         ‚ïë ${String(pokemon1.stats.attack).padEnd(8)} ‚ïë ${String(pokemon2.stats.attack).padEnd(8)} ‚ïë
‚ïë Defesa         ‚ïë ${String(pokemon1.stats.defense).padEnd(8)} ‚ïë ${String(pokemon2.stats.defense).padEnd(8)} ‚ïë
‚ïë Atq. Especial  ‚ïë ${String(pokemon1.stats.specialAttack).padEnd(8)} ‚ïë ${String(pokemon2.stats.specialAttack).padEnd(8)} ‚ïë
‚ïë Def. Especial  ‚ïë ${String(pokemon1.stats.specialDefense).padEnd(8)} ‚ïë ${String(pokemon2.stats.specialDefense).padEnd(8)} ‚ïë
‚ïë Velocidade     ‚ïë ${String(pokemon1.stats.speed).padEnd(8)} ‚ïë ${String(pokemon2.stats.speed).padEnd(8)} ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë **TOTAL**          ‚ïë **${String(pokemon1.stats.total).padEnd(8)}** ‚ïë **${String(pokemon2.stats.total).padEnd(8)}** ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üè∑Ô∏è **Tipos:**
‚Ä¢ ${pokemon1.nameCapitalized}: ${pokemon1.types.join(', ')}
‚Ä¢ ${pokemon2.nameCapitalized}: ${pokemon2.types.join(', ')}

${pokemon1.stats.total > pokemon2.stats.total 
  ? `üèÜ ${pokemon1.nameCapitalized} tem stats totais superiores!` 
  : pokemon1.stats.total < pokemon2.stats.total 
    ? `üèÜ ${pokemon2.nameCapitalized} tem stats totais superiores!`
    : `‚öñÔ∏è Ambos t√™m stats totais iguais!`}

---
Digite "menu" para voltar ou compare outros Pok√©mon!`;

    newState = utils.addMessage(newState, 'assistant', response, { pokemon1, pokemon2 });
    newState = utils.updateContext(newState, {
      comparisonData: [pokemon1, pokemon2],
      waitingFor: 'next_action',
      lastError: null
    });
    newState = utils.incrementInteraction(newState);
    
    // Marca que o input foi processado e aguarda pr√≥xima a√ß√£o
    newState.userInput = '';
    newState.currentNode = 'compare';

  } catch (error) {
    console.error('[ERROR] compareNode:', error.message);

    const errorMessage = `‚ùå ${error.message}\n\nTente novamente ou digite "menu" para voltar.`;
    
    newState = utils.addMessage(newState, 'assistant', errorMessage);
    newState = utils.updateContext(newState, {
      lastError: error.message,
      waitingFor: 'pokemon_input'
    });
    
    // Marca que o input foi processado (mesmo com erro)
    newState.userInput = '';
    newState.currentNode = 'compare';
  }

  return newState;
};

// ============================================
// N√ì 5: EVOLUTION (Cadeia de Evolu√ß√£o)
// ============================================
const evolutionNode = async (state) => {
  console.log('[NODE] evolutionNode - Buscando evolu√ß√£o');

  const input = state.userInput.trim();
  let newState = utils.addMessage(state, 'user', input);

  try {
    // Buscar Pok√©mon
    const pokemon = await pokeService.getPokemon(input);
    const species = await pokeService.getSpecies(pokemon.speciesId);
    const evolutionChain = await pokeService.getEvolutionChain(species.evolutionChainId);

    const response = `
üîÑ **Cadeia Evolutiva de ${pokemon.nameCapitalized}**

${evolutionChain.map((evo, index) => {
  const arrow = index < evolutionChain.length - 1 ? ' ‚û°Ô∏è ' : '';
  return `**${evo.nameCapitalized}**${arrow}`;
}).join('')}

üìä Total de formas: ${evolutionChain.length}

---
Digite outro Pok√©mon ou "menu" para voltar.`;

    newState = utils.addMessage(newState, 'assistant', response, evolutionChain);
    newState = utils.updateContext(newState, {
      evolutionChain,
      waitingFor: 'next_action',
      lastError: null
    });
    newState = utils.incrementInteraction(newState);
    
    // Marca que o input foi processado e aguarda pr√≥xima a√ß√£o
    newState.userInput = '';
    newState.currentNode = 'evolution';

  } catch (error) {
    console.error('[ERROR] evolutionNode:', error.message);

    const errorMessage = `‚ùå Erro ao buscar evolu√ß√£o: ${error.message}\n\nTente novamente ou digite "menu" para voltar.`;
    
    newState = utils.addMessage(newState, 'assistant', errorMessage);
    newState = utils.updateContext(newState, {
      lastError: error.message
    });
    
    // Marca que o input foi processado (mesmo com erro)
    newState.userInput = '';
    newState.currentNode = 'evolution';
  }

  return newState;
};

// ============================================
// N√ì 6: TYPE_SEARCH (Buscar por Tipo)
// ============================================
const typeSearchNode = async (state) => {
  console.log('[NODE] typeSearchNode - Buscando por tipo');

  const input = state.userInput.trim().toLowerCase();
  let newState = utils.addMessage(state, 'user', input);

  // Verificar comandos especiais antes de buscar por tipo
  if (input.includes('menu')) {
    const response = 'üìã Voltando ao menu principal...';
    newState = utils.addMessage(newState, 'assistant', response);
    newState = utils.incrementInteraction(newState);
    newState.userInput = '';
    newState.currentNode = 'menu';
    return newState;
  }

  try {
    const pokemonList = await pokeService.getPokemonByType(input);

    const response = `
üè∑Ô∏è **Pok√©mon do tipo ${input.toUpperCase()}**

${pokemonList.slice(0, 15).map((p, i) => `${i + 1}. ${p.name}`).join('\n')}

${pokemonList.length > 15 ? `\n... e mais ${pokemonList.length - 15} Pok√©mon!` : ''}

---
Digite o nome de um Pok√©mon para mais detalhes ou "menu" para voltar.`;

    newState = utils.addMessage(newState, 'assistant', response, pokemonList);
    newState = utils.updateContext(newState, {
      waitingFor: 'next_action',
      lastError: null
    });
    newState = utils.incrementInteraction(newState);
    
    // Marca que o input foi processado e aguarda pr√≥xima a√ß√£o
    newState.userInput = '';
    newState.currentNode = 'type_search';

  } catch (error) {
    console.error('[ERROR] typeSearchNode:', error.message);

    const errorMessage = `
‚ùå Tipo "${input}" n√£o encontrado.

Tipos v√°lidos incluem:
‚Ä¢ normal, fire, water, grass, electric
‚Ä¢ ice, fighting, poison, ground, flying
‚Ä¢ psychic, bug, rock, ghost, dragon
‚Ä¢ dark, steel, fairy

Tente novamente ou digite "menu" para voltar.`;
    
    newState = utils.addMessage(newState, 'assistant', errorMessage);
    newState = utils.updateContext(newState, {
      lastError: error.message
    });
    
    // Marca que o input foi processado (mesmo com erro)
    newState.userInput = '';
    newState.currentNode = 'type_search';
  }

  return newState;
};

// ============================================
// N√ì 7: END (Finalizar)
// ============================================
const endNode = async (state) => {
  console.log('[NODE] endNode - Finalizando conversa');

  const sessionDuration = Date.now() - state.metadata.startTime;
  const minutes = Math.floor(sessionDuration / 60000);
  const seconds = Math.floor((sessionDuration % 60000) / 1000);

  const response = `
üëã **At√© logo, Treinador!**

üìä **Resumo da sess√£o:**
‚Ä¢ Intera√ß√µes: ${state.metadata.interactionCount}
‚Ä¢ Dura√ß√£o: ${minutes}m ${seconds}s

Obrigado por usar o Pok√©Dex Assistant! 
Volte sempre que precisar de ajuda na sua jornada Pok√©mon! üéÆ‚ú®`;

  let newState = utils.addMessage(state, 'assistant', response);
  newState.currentNode = 'end';

  return newState;
};

// ============================================
// EXPORTS
// ============================================
module.exports = {
  initialState,
  nodes: {
    start: startNode,
    menu: menuNode,
    search: searchNode,
    compare: compareNode,
    evolution: evolutionNode,
    type_search: typeSearchNode,
    end: endNode
  },
  utils
};